# RFC 002: Improved Telemetry Configuration for Satellite Extensions

## Summary

Replace the current function-based telemetry property sharing mechanism with a direct property exposure approach that eliminates circular dependencies and simplifies satellite extension telemetry configuration. Satellite extensions will access telemetry data directly through the service collection rather than through lambda functions passed during construction.

While addressing the core architectural issues, this RFC also includes cleanup improvements to the `TelemetryService` API including constructor simplification and method renaming for better developer experience.

## Background

Currently, satellite extensions configure their `TelemetryService` with an `updateDefaultPropertiesFunction` that fetches common properties from the core extension's telemetry service. This creates several issues:

1. **Circular Dependency**: Satellite extensions need the `IFabricExtensionManager` to get the telemetry function, but the manager isn't available until after the telemetry service is constructed
2. **API Pollution**: The `IFabricExtensionManager` interface is forced to expose `getFunctionToFetchCommonTelemetryProperties()`, which violates single responsibility principle - an extension manager shouldn't be concerned with telemetry implementation details
3. **Confusing Architecture**: Passing lambda functions that fetch properties creates unclear data flow and makes the system harder to understand
4. **Limited Flexibility**: Satellite extensions cannot easily add their own common properties alongside core properties

The current implementation requires this pattern in satellite extensions:

```typescript
const telemetryService = new TelemetryService(container.get<TelemetryReporter>(), {
    updateDefaultPropertiesFunction: container.get<IFabricExtensionManager>().getFunctionToFetchCommonTelemetryProperties(),
});
```

## Proposal

### New Telemetry Property Provider Interface

Add a new interface to the API package:

```typescript
export interface ITelemetryPropertyProvider {
    /**
     * Gets the current common telemetry properties
     */
    getCommonProperties(): { [key: string]: string };

    /**
     * Event fired when common telemetry properties change
     */
    onDidPropertiesChange: vscode.Event<void>;
}
```

### Enhanced Service Collection

Extend `IFabricExtensionServiceCollection` to include the telemetry property provider:

```typescript
export interface IFabricExtensionServiceCollection {
    artifactManager: IArtifactManager;
    workspaceManager: IWorkspaceManager;
    apiClient: IFabricApiClient;
    telemetryPropertyProvider: ITelemetryPropertyProvider; // New
}
```

### TelemetryService API Improvements

Along with the new property provider pattern, simplify the `TelemetryService` API:

1. **Simplified Constructor**: Remove options object and use direct parameters
2. **Cleaner Property API**: Rename `addOrUpdateDefaultProperty` to `setProperty`
3. **Late Provider Binding**: Support connecting to property provider after initialization
4. **Interface Definition**: Add `ITelemetryService` interface for better abstraction and testing

### New TelemetryService Interface

Add a new interface to define the telemetry service contract:

```typescript
export interface ITelemetryService extends IDisposable {
    /**
     * Gets the currently configured VS Code telemetry level
     */
    getTelemetryLevel(): string | undefined;

    /**
     * Sends a telemetry event with the given properties and measurements
     */
    sendTelemetryEvent(eventName: string, properties?: { [key: string]: string }, measurements?: { [key: string]: number }): void;

    /**
     * Sends a telemetry error event with the given properties and measurements
     */
    sendTelemetryErrorEvent(error: any, properties?: { [key: string]: string }, measurements?: { [key: string]: number }): void;

    /**
     * Set or update a default telemetry property
     */
    setProperty(key: string, value: string | undefined): void;

    /**
     * Connect to a telemetry property provider after initialization
     */
    setPropertyProvider(provider: ITelemetryPropertyProvider): void;
}
```

### Updated TelemetryService Constructor

Modify the `TelemetryService` to implement the new interface and support both early initialization and later property provider connection:

```typescript
export class TelemetryService implements ITelemetryService {
    constructor(
        private readonly telemetryReporter: TelemetryReporter,
        extensionMode?: number,
        telemetryPropertyProvider?: ITelemetryPropertyProvider
    )

    /**
     * Connect to a telemetry property provider after initialization
     * Allows early telemetry service creation with later core property integration
     */
    public setPropertyProvider(provider: ITelemetryPropertyProvider): void {
        this.telemetryPropertyProvider = provider;
        
        // Immediately sync current properties from the provider
        this.syncPropertiesFromProvider();
        
        // Subscribe to property changes to keep satellite properties in sync
        provider.onDidPropertiesChange(() => {
            this.syncPropertiesFromProvider();
        });
    }

    /**
     * Synchronizes properties from the connected property provider
     * Updates the satellite's default properties with current core properties
     */
    private syncPropertiesFromProvider(): void {
        if (!this.telemetryPropertyProvider) {
            return;
        }
        
        const coreProperties = this.telemetryPropertyProvider.getCommonProperties();
        
        // Merge core properties with satellite's own properties
        // Satellite properties take precedence for common keys
        this.defaultProps = {
            ...coreProperties,    // Core properties (tenant, environment, etc.)
            ...this.defaultProps  // Satellite's own properties (extensionMode, etc.) - take precedence
        };
    }

    /**
     * Set or update a default telemetry property
     * Renamed from addOrUpdateDefaultProperty for clarity
     */
    public setProperty(key: string, value: string | undefined): void {
        // Implementation remains the same
    }

    /**
     * Dispose of the telemetry service and underlying resources
     * Implements IDisposable for proper resource cleanup
     */
    public dispose(): Promise<void> {
        // Implementation remains the same - delegate to telemetryReporter
    }
}
```

### Implementation in Core Extension

The core extension will implement `ITelemetryPropertyProvider` and expose it through the service collection:

```typescript
export class FabricTelemetryPropertyProvider implements ITelemetryPropertyProvider {
    private readonly onDidPropertiesChangeEmitter = new vscode.EventEmitter<void>();
    public readonly onDidPropertiesChange = this.onDidPropertiesChangeEmitter.event;

    constructor(private telemetryService: TelemetryService) {}

    getCommonProperties(): { [key: string]: string } {
        return this.telemetryService.defaultProps;
    }

    public notifyPropertiesChanged(): void {
        this.onDidPropertiesChangeEmitter.fire();
    }
}
```

The core extension will trigger property change notifications when key properties are updated:

```typescript
// In core extension activation - when environment changes
fabricEnvironmentProvider.onDidEnvironmentChange(async () => {
    const environment = fabricEnvironmentProvider.getCurrent();
    if (environment) {
        telemetryService.setProperty('fabricEnvironment', environment.env);
        fabricTelemetryProvider.notifyPropertiesChanged(); // Notify satellites
    }
});

// When user signs in/out or switches tenants
account.onSignInChanged(async () => {
    const sessionProperties = await account.getDefaultTelemetryProperties();
    telemetryService.setProperty('tenantid', sessionProperties.tenantid);
    telemetryService.setProperty('useralias', sessionProperties.useralias);
    telemetryService.setProperty('ismicrosoftinternal', sessionProperties.isMicrosoftInternal);
    fabricTelemetryProvider.notifyPropertiesChanged(); // Notify satellites
});
```

### Satellite Extension Usage

Satellite extensions will initialize telemetry early but connect to core properties after registration:

```typescript
// Early telemetry initialization during container composition (no core properties yet)
const telemetryService = new TelemetryService(
    container.get<TelemetryReporter>(),
    context.extensionMode
);

// Later, after core registration, connect to shared properties
const fabricServiceCollection = this.fabricExtensionManager.addExtension({...});
telemetryService.setPropertyProvider(fabricServiceCollection.telemetryPropertyProvider);
```

### Core Extension Usage

The core extension will initialize with extension mode and set properties directly:

```typescript
// Core extension initialization with extension mode
const telemetryService = new TelemetryService(
    container.get<TelemetryReporter>(), 
    context.extensionMode
);

// Set Fabric-specific properties using cleaner API
telemetryService.setProperty('fabricEnvironment', environment.env);
telemetryService.setProperty('tenantid', tenantInfo.id);
```

## Implementation

### Dependencies

1. Update `@fabric/vscode-fabric-api` package with new interfaces
2. Update `@fabric/vscode-fabric-util` package with `TelemetryService` changes  
3. Update core extension to implement and expose property provider
4. Update satellite extensions to use new pattern

### Migration Strategy

1. **Phase 1**: Add new interfaces and optional property provider support to `TelemetryService`
2. **Phase 2**: Implement property provider in core extension and expose through service collection
3. **Phase 3**: Update satellite extensions to use new pattern
4. **Phase 4**: Remove deprecated `updateDefaultPropertiesFunction` and `getFunctionToFetchCommonTelemetryProperties`

### Testing Approach

- Unit tests for `ITelemetryPropertyProvider` implementation
- Integration tests verifying telemetry properties are correctly shared between core and satellite extensions
- Tests ensuring property updates are propagated via events

## Alternatives Considered

### Option 1: Keep Current Function-Based Approach
**Rejected**: Doesn't address the circular dependency and architectural confusion issues.

### Option 2: Delayed Telemetry Service Initialization
**Rejected**: While this would solve the dependency issue, it introduces unacceptable risks:
- Critical activation errors could be lost if telemetry isn't available immediately
- Extension bootstrap failures wouldn't be captured for diagnostics
- DI container composition errors would go unreported
- The timing window (milliseconds between service creation and core registration) is small enough that missing common properties on early events is acceptable

### Option 3: Global Telemetry Registry
**Rejected**: Would introduce singleton patterns that complicate testing and violate dependency injection principles.

## Risks & Mitigations

### Risk: Delayed Core Property Integration
**Concern**: Telemetry events sent before core registration won't include common properties like tenant, environment, etc.

**Mitigation**: This is acceptable because:
- Early telemetry events (activation errors, initialization failures) are more critical than having complete property sets
- Common properties are primarily useful for user session analysis, not bootstrap/error diagnostics  
- The delay between telemetry service creation and core registration is minimal (typically milliseconds)
- Extension-specific properties can still be added immediately by satellite extensions

### Risk: Breaking Changes for Satellite Extensions
**Mitigation**: Use phased migration approach with backward compatibility maintained during transition period.

### Risk: Property Update Event Performance
**Mitigation**: Events are fired only when properties actually change (tenant switches, environment changes), not on every telemetry call.

### Risk: Service Collection Dependency Order
**Mitigation**: Property provider is available immediately after extension registration, eliminating timing dependencies.
